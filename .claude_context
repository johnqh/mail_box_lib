# @johnqh/lib - AI Development Context

## Project Overview
A React Native-compatible shared utilities library for 0xmail.box projects, providing platform-agnostic business logic, authentication, email handling, blockchain integration, and UI utilities.

### Key Features
- **Platform Abstraction**: Works on both web and React Native
- **Business Logic Layer**: Pure domain logic separate from platform concerns
- **Interface-First Design**: TypeScript interfaces drive implementation
- **Blockchain Integration**: Supports Solana and EVM chains
- **Email Services**: Full email client functionality with AI assistance
- **Points System**: Gamified user engagement and rewards
- **Dependency Injection**: Clean architecture with configurable services

### Current Version: 2.1.0
- Recently updated indexer API client to match new signature-protected endpoints
- Removed admin functionality (no longer supported by backend)
- Added new Solana and simplified points API support

## Quick Start for AI Assistants

### Most Common Tasks
1. **Add a new service**: Start with interface in `src/types/services/`, then operations in `src/business/core/`, then platform implementations
2. **Fix a bug**: Search with Grep, write failing test first, then fix
3. **Add a hook**: Create in `src/business/hooks/`, use existing patterns
4. **Update API client**: Modify `src/network/clients/`, ensure signature auth

### Essential Commands
```bash
npm run typecheck     # Check TypeScript types
npm test             # Run all tests
npm run lint:fix     # Fix lint issues
npm run build        # Build the library
```

### File Patterns to Remember
- `*.interface.ts` - TypeScript interfaces
- `*.web.ts` - Web-specific implementations
- `*.reactnative.ts` - React Native implementations
- `*-operations.ts` - Business logic operations
- `index.ts` - Barrel exports (always update!)

## Architecture
```
src/
├── business/           # Core business logic layer
│   ├── ai/            # AI-powered email services
│   ├── core/          # Domain operations (auth, email, analytics)
│   ├── hooks/         # React hooks for data fetching
│   └── points/        # Rewards/points system
├── di/                # Dependency injection & environment
├── network/           # Platform-agnostic networking
├── storage/           # Platform-agnostic storage
├── types/             # TypeScript interfaces & types
└── utils/             # Platform-specific implementations
```

## Key Patterns

### Platform Abstraction
- Interface-first design with `.interface.ts` files
- Platform-specific implementations: `.web.ts`, `.reactnative.ts`
- Automatic platform detection in main files

### Business Logic Layer
- Pure business logic in `src/business/core/`
- Operations classes for domain logic
- Hooks for React integration in `src/business/hooks/`

### Dependency Injection
- Container pattern in `src/business/core/container/`
- Environment-based configuration in `src/di/`

## Development Guidelines

### File Naming Conventions
- Interfaces: `*.interface.ts`
- Web implementations: `*.web.ts`
- React Native implementations: `*.reactnative.ts`
- Tests: `*.test.ts` or `*.spec.ts`
- Business operations: `*-operations.ts`

### Code Organization
- Group related functionality in directories
- Use index files for clean exports
- Separate interfaces from implementations
- Keep platform-specific code isolated

### TypeScript Best Practices
- Use strict typing throughout
- Define interfaces for all data structures
- Use generics for reusable components
- Export types alongside implementations

## Testing Strategy
- Unit tests in `__tests__` directories
- React hooks testing with @testing-library/react
- Platform-agnostic business logic testing
- Mock external dependencies

## Key Dependencies
- React Native compatible packages only
- Firebase for backend services
- Blockchain: @solana/web3.js, viem
- Crypto: @noble/hashes, bs58
- Testing: Vitest, @testing-library/react

## AI Development Tips

### When adding new features:
1. **Define Interface First**: Start with interface definition in `types/services/`
2. **Business Logic**: Implement pure logic in `business/core/[domain]/`
3. **Platform Implementations**: Create `.web.ts` and `.reactnative.ts` files
4. **React Integration**: Add hooks in `business/hooks/[domain]/`
5. **Comprehensive Testing**: Write tests in `__tests__` directories
6. **Export Management**: Update relevant `index.ts` files

### When debugging issues:
- **Platform Detection**: Check if correct platform implementation is loaded
- **Interface Compliance**: Verify implementations match their interfaces
- **Dependency Injection**: Review service registration in DI container
- **Environment Config**: Validate configuration in `src/di/environment/`
- **API Signatures**: Ensure API client methods match backend endpoints

### Critical Patterns to Follow:
- **Signature Protection**: All indexer API calls now require `walletAddress`, `signature`, `message`
- **Error Handling**: Use consistent error patterns with typed exceptions
- **Type Safety**: Export interfaces alongside implementations
- **Platform Isolation**: Keep platform-specific code in `utils/` directory
- **Business Purity**: Keep business logic free of platform dependencies

### Recent Changes to Consider:
- **No Admin Endpoints**: Admin functionality has been removed from indexer API
- **New API Structure**: Points API now uses `/api/points/*` endpoints
- **Solana Support**: New `/api/solana/*` endpoints for Solana blockchain integration
- **Signature Verification**: All protected endpoints now use unified signature verification

## Code Quality Checklist

Before committing any changes:
- [ ] Run `npm run typecheck` - No TypeScript errors
- [ ] Run `npm test` - All tests pass
- [ ] Run `npm run lint:fix` - Code is properly formatted
- [ ] Check imports - No platform-specific imports in business logic
- [ ] Update exports - All new code exported from index.ts files
- [ ] Add tests - New features have test coverage

## Common Code Patterns

### Service Factory Pattern
```typescript
// src/utils/my-service/index.ts
export const createMyService = (): MyService => {
  if (Platform.OS === 'web') {
    const { WebMyService } = require('./my-service.web');
    return new WebMyService();
  } else {
    const { ReactNativeMyService } = require('./my-service.reactnative');
    return new ReactNativeMyService();
  }
};
```

### Hook Pattern with Error Handling
```typescript
export const useMyData = () => {
  const [data, setData] = useState<DataType | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const fetch = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await service.getData();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, []);
  
  return { data, loading, error, fetch };
};
```

### Error Class Pattern
```typescript
export class ServiceError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'ServiceError';
  }
}
```

## External Integrations
- WildDuck email server (via symbolic link)
- Mail indexer service (via symbolic link)
- Solana blockchain
- Firebase services
- RevenueCat (mobile subscriptions)

## Build & Test Commands
- `npm run build` - TypeScript compilation
- `npm test` - Run all tests with Vitest
- `npm run test:run` - Run tests once
- `npm run clean` - Clean dist directory